# Do it! Java Programming

# Java Fundamental (2023.01.27 - 2023.02.05)

## 2023.01.27

### 학습할 내용

- 자바의 장점
- 필요 환경 구성
- 변수 및 자료형

### 학습한 내용

- 자바의 장점
  - 플랫폼에 영향을 받지 않는다.
    - `Java`는 플랫폼의 영향을 받지 않는다. `Java`를 컴파일 할 경우 `.class`의 확장자를 갖게되며, 이는 중간 기계어로, 운영체제에 맞는 `자바 가상 머신`을 활용하여야 실행이 가능하다.
      `OS`에 맞는 가상 머신을 활용하여 플랫폼에 영향을 받지 않는 소프트웨어를 구축할 수 있게되며, 이는 `한 번 작성하면, 어디서든 돌아간다`는 `Java`의 슬로건에 따른 결과이다.
  - 객체지향 언어로 유지보수가 쉽고 확장성이 좋다.
    - 클래스를 활용하여 공통되는 부분을 쉽게 추가하여 사용할 수 있기 때문에, 유지보수가 쉽고 확장성이 좋다.
  - 안정적이다.
    - `C`나 `C++`과 달리 `포인터`를 사용하지 않기 때문에 메모리를 직접 제어할 일이 없으므로 안정된 코드를 만들 수 있다.
    - `가비지 컬렉터 (GC)`가 사용하지 않는 동적 메모리를 주기적으로 수거하기 때문에 효율적인 관리 또한 가능하다.
  - 오픈소스
    - 오픈소스이며, 개발된 기능들을 활용해 개발하고자 하는 부분에 대해 빠른 구현이 가능하다.
- 변수 및 자료형
  - 정수 자료형
    - byte
    - short
    - int
    - long
  - 문자 자료형
    - char
  - 실수 자료형
    - float
    - double
  - 논리 자료형
    - boolean
  - 추론형
    - var
- 형 변환
  - 묵시적 형 변환
    - 바이트 크기가 작은 자료형 → 큰 자료형 (데이터 손실 발생하지 않음)
  - 명시적 형 변환
    - 바이트 크기가 큰 자료형 → 작은 자료형 (데이터 손실 발생)

## 2023.01.28

### 학습할 내용

- 연산자에 대한 이해
  - 기본 연산자
  - 비트 연산자
- 제어 흐름 이해
  - 조건문
  - 반복문
- 클래스와 객체
  - 클래스란?
    - 멤버 변수 및 메서드에 대한 이해
  - 함수란?
    - 함수 호출과 스택 메모리
    - 함수의 장점
  - 클래스와 인스턴스
    - 클래스 생성방법 및 인스턴스와 참조 변수
    - 인스턴스와 힙 메모리
  - 생성자
    - 생성자 오버로드
  - 참조 자료형
  - 정보 은닉
    - 접근 제어자
    - getter, setter
  - this란?
  - static 변수
  - 싱글톤 패턴

### 학습한 내용

- 연산자에 대한 이해
  - 기본 연산자
    - 항
      - 단항 연산자
        - ++, — 등
      - 이항 연산자
        - num1+num2
      - 삼항 연산자
        - num1 > num2 ? true : false
    - 대입 연산자
      - int num1 = 3
    - 부호 연산자
      - +3, -3
    - 산술 연산자
      - +, -, \*, /, %
    - 증감 연산자
      - ++, —
    - 관계 연산자
      - > , <, ≥, ≤, ==, ≠
    - 논리 연산자
      - &&, ||, !
    - 복합 대입 연산자
      - +=, -=, …
  - 비트 연산자
    - 비트 논리 연산자
      - &, |, ^, ~
    - 비트 이동 연산자
      - > > , <<, >>>
- 제어 흐름 이해
  - 조건문
    - if & else
    - switch
  - 반복문
    - while
    - do-while
    - for
- 클래스와 객체
  - 클래스
    - `멤버변수`: 클래스 내부에서 다루는 변수
    - `메서드`: 클래스 내부에서 멤버 변수를 활용할 목적으로 선언된 함수
      - 반환 값이 없는 메서드는 `void`를 선언한다.
    - `패키지`: 클래스 파일의 묶음(같은 이름의 클래스라도, 패키지 이름이 다르면 다른 클래스)
  - 함수
    - `main` 외부에서 선언된 함수는 `static`을 붙여주어야 사용이 가능하다.
    - 함수를 호출하면 `스택`의 형태로 메모리 공간이 만들어지며 `LIFO`형태로 반환된다.
    - 함수 내부에서 사용하는 변수를 `지역 변수`라고 부르고, `지역 변수`는 `스택 메모리`에 생성된다.
  - 인스턴스
    - new 예약어로 호출된 생성자 클래스를 담고있는 변수를 `인스턴스`라고 한다.
      - 이 때, `인스턴스`는 `힙 메모리`에 클래스가 저장되며, `스택 메모리`에 변수가 저장된다.
    - `힙 메모리`란, 동적 메모리 공간으로, 사용이 끝난 후 프로그래머가 해제해줘야 하지만, 앞서 정리했듯이 `Java`는 `가비지 컬렉터(GC)`가 자동으로 사용하지 않는 메모리를 해제해준다.
  - 생성자
    - new 예약어 뒤에 오는 클래스 이름을 `생성자`라고 한다.
    - 개발자가 정의하지 않는 경우 자동으로 생성자는 생성됨
    - 생성자가 두 개 이상이거나, 메서드 이름이 같고 매개변수만 다른 경우를 `오버로드`라고 한다.
  - 접근 제어자
    - `public`: 외부클래스 어디에서나 접근 가능
    - `protected`: 같은 패키지 내부, 상속 관계의 클래스에서 접근 가능
    - 아무것도 없는 경우: `default`로 같은 패키지 내부에서만 접근 가능
    - `private`: 같은 클래스 내부에서만 접근 가능
    - `getter`: 값을 얻는 메서드
    - `setter`: 값을 지정하는 메서드
      - 클래스에 입력된 값이 올바르지 못한 정보라면, 접근을 제어해야 하므로 사용됨
  - this
    - `public`은 파일명과 같은 `class`만 가질 수 있다.. ~~몰라서 에러가 많이 났음..~~
    - 생성된 인스턴스 스스로를 가르키는 예약어
  - static
    - `static`은 다른 멤버 변수와 같은 방식으로 클래스 내부에 `static`을 붙여 선언하며, 매번 새로 생성되는 변수가 아닌 모든 인스턴스가 공유하는 변수이다.
    - `클래스 변수`라고도 불린다.
  ※ 변수 유형 정리
  - 함수에서의 기능 구현 → 지역 변수
  - 클래스의 속성, 각 인스턴스 별 값 → 멤버 변수
  - 여러 인스턴스에서 공유 → static 변수
  - 싱글톤 패턴
    - 단 하나의 인스터만 필요한 경우 활용되는 패턴이다.
    1. 생성자를 private으로 만들기
    2. 클래스 내부에 static으로 유일 인스턴스 생성하기
    3. 외부에서 참조할 수 있는 public 메서드 만들기
    4. 실사용 코드 만들기

## 2023.01.29

### 학습할 내용

- 배열 & ArrayList
  - 배열
  - 다차원 배열
  - ArrayList 클래스
- 상속 & 다형성
  - 상속
  - 상속에서 클래스 생성 및 형 변환
  - 메서드 오버라이딩
  - 다형성
  - 다운캐스팅 & instance of
- 추상 클래스
  - 템플릿 메서드
  - final

### 학습한 내용

- 배열
  - 자료형[] (변수이름) = new 자료형[] {} 의 구조로 선언
  - System.arraycopy(src, srcPos, dest, destPos, length)
    - src의 srcPos번째 요소부터 length만큼의 수를 dest배열의 destPos번째 요소부터 붙여넣는다.
  - 얕은 복사
    - `arraycopy`를 통해 복사된 인스턴스는 서로 같은 주소를 가르키는 `얕은 복사` 상태가 된다.
    - 해당 상태에서는 원본 배열에 변화에 따라 복사된 배열의 값이 변화한다.
  - 깊은 복사
    - 깊은 복사는, 배열의 각 요소에 인스턴스를 생성하고 값을 할당해야한다.
    - 해당 상태에서 원본 배열에 변화가 있다하더라도, 복사된 배열은 변화하지 않는다.
  - ArrayList
    - 제네릭 타입으로 선언된 ArrayList를 다루는 방법과, 객체 배열을 입력하여 입출력을 구현하는 방법에 대해 학습
- 상속과 다형성
  - 상속
    - `extends` 키워드를 사용해 구현되며, 해당 키워드를 기준으로 전자는 `하위 클래스` 후자는 `상위 클래스` 라고 한다.
    - 상위 클래스
      - 상위 클래스는 하위 클래스에서 접근이 가능하며, 외부에서의 접근을 차단하는 방법으로 `protected` 를 사용하면 된다.
    - 하위 클래스
      - 하위 클래스는 상속받은 상위 클래스의 메서드를 사용할 수 있다.
      - `super` 키워드를 통해 상위 클래스의 생성자를 호출할 수 있다.
    - 상속받는 경우 상위 클래스의 생성자가 먼저 호출된 후 변수를 메모리에 할당하고 하위클래스의 생성자를 호출한다.
  - 형 변환
    - 하위 클래스는 상위 클래스의 형으로 변환이 가능하며, 이 때 사용 가능한 메서드는 상위 클래스의 메서드로 한정된다.
  - 메서드 오버라이딩
    - `메서드 오버라이딩`이 발생한 경우, 상위 클래스의 메서드를 호출할 때 `super.methodName()` 의 방식으로 호출해야한다.
    - `@Overide` 키워드는 오버라이딩 될 메서드 위에 선언하며, 컴파일러에 알려주는 역할을 한다.
  - 다형성
    - 같은 클래스형으로 선언된 인스턴스라도, 생성자에 따라 오버라이딩 된 메서드가 호출될 수 있다.
  - 다운 캐스팅
    - 상위 클래스로 형을 지정하고 하위 클래스의 생성자를 호출한 경우, 하위 클래스의 메서드를 사용하기 위해 `하위클래스의 자료형으로 형 변환하는 것`
    - `instanceof` : 다운캐스팅을 위해 인스턴스의 원 자료형을 확인하는 용도로 사용
  - 추상화
    - 추상화란, 구현할 메서드의 추상적인 모습(이름, 인자)을 정의해놓은 구조를 의미하며 `abstract` 를 붙여 선언한다.
    - 메서드 뿐 아니라 추상 메서드가 속한 클래스에도 `abstract` 를 붙여 선언해야 오류를 방지할 수 있다.
    - 추상 클래스를 상속받는다면, 해당 클래스 또한 추상 메서드를 모두 선언하거나, 추상 클래스로 선언되어야 한다.
      - 이 때, 하위 클래스에서 `@Override` 를 선언한 메서드로 추상화했던 메서드를 구현할 수 있다.
    - 추상 클래스는 `new` 예약어로 인스턴스를 생성할 수 없다.
    - `왜 쓸까??` → 하위 클래스에서 사용할 메서드의 추상적인 면을 생성 (상속을 위해)
    - 구현 내용이 달라진다 → 추상 메서드
    - 공통으로 사용한다 → 구현
  - 템플릿 메서드
    - `final` 예약어를 통해 시나오리를 정의하는 메서드로, 하위 클래스에서 재정의 할 수 없어야 하며로직의 흐름을 나타낸다.
  - final 예약어
    - `변수` → 상수를 의미한다.
    - `메서드` → 하위 클래스에서 재정의할 수 없다.
    - `클래스` → 상속할 수 없다.
    - 프로젝트를 진행할 때 여러 파일에서 공유해야하는 `상수` 를 한 파일에 놓아 선언하여 사용

## 2023.01.30

### 학습할 내용

- 인터페이스
  - 추상 메서드
  - implements
  - 다중 상속
- 기본 클래스
  - Object
  - String
  - Wrapper
  - Class

### 학습한 내용

- 인터페이스
  - 구현 코드가 없는 추상 메서드로 `abstract` 예약어를 명시하지 않아도 추상 메서드로 변환된다.
  - `implements` 예약어로 적용이 가능하며, 모든 메서드를 구현하지 않는다면, 선언된 클래스 또한 추상 클래스로 전환된다.
  - `왜 쓸까?` 인터페이스를 구현한 클래스가 어떤 기능의 메서드를 제공하는지 명시하는 기능으로 사용된다.
  - 하나의 클래스는 다중 인터페이스를 상속받을 수 있다.
- 기본 클래스
  - 모든 원시 자료형은 `java.lang` 의 위치에 존재하며, 기본적으로 컴파일 될 때 `extends` 시키기 때문에 프로그래머가 직접 작성할 필요는 없다.
  - object
    - `toString` → 메서드의 인스턴스 정보를 보여줌
    - `String` , `Integer` 형은 재정의된 메서드를 사용해 object.(class)@(hashcode)의 구성이 아닌 매개변수 그 자체를 호출한다.
      - `@Override` 를 통해 클래스의 `toString` 함수를 구현하여 원하는대로 결괏값 추출이 가능하다.
    - `equals` → 두 요소가 같은지 비교
      - 할당된 주솟값을 기준으로 비교하기에 같은 클래스 이더라도 기대치 않는 결괏값이 나올 수 있음
    - `hashCode` → 해당 요소의 주솟값을 출력
      - `equals` 메서드를 오버라이딩 한 경우, 해당 메서드도 같은 해시 코드를 가르키도록 변경해주어야 한다.
  - string
    ```java
    String str1 = new String("123"); // 힙 메모리에 저장
    String str2 = "123"; // 상수 풀에 저장
    ```
    - `StringBuilder` 를 사용하면, 문자열이 변함에 따라 새 주소를 할당하지 않고 기존 주소에 연결된다. 즉 효율이 상승
  - wrapper
    - 기본 자료형을 멤버 변수로 포함하여 메서드를 제공함으로써, 기본 자료형의 객체를 제공하는 클래스이다.
  - class
    - `Class` 자료형의 다양한 메서드를 사용해 클래스의 이름을 가져올 수 있다.
    - `getClass`, `{ClassName}.class` , `Class.forName`
    - 이 중 `Class.forName` 은 매개변수로 전달되는 문자열을 통해 클래스의 동적 로딩이 가능하기 때문에, 유연한 사용이 가능하다.

## 2023.01.31

### 학습할 내용

- 컬렉션 프레임워크
  - 제네릭
  - Collection & Map 인터페이스
- List 인터페이스
  - ArrayList & Vector 클래스
  - LinkedList 클래스
  - 스택 & 큐
  - Iterator

### 학습한 내용

- 컬렉션 프레임워크
  - 제네릭
    - 하나의 참조형이 아닌 여러 참조형을 사용할 수 있도록 선언함
    - 제네릭으로 구현하면 `<T>` 에 선언된 자료형에 따라 맞추어 컴파일하므로, 형변환을 하지 않아도 된다.
    - `<T extends {ClassName}>` 의 형태로 제네릭에 사용 가능한 자료형에 제한을 둘 수 있다.
    - `<>` 이것을 다이아몬드 연산자 라고 부르며, 연산자만 사용하고 인스턴스의 자료형을 명시하지 않아도 컴파일러는 할당되는 클래스의 자료형을 보고 인스턴스의 자료형을 유추할 수 있다.
  - 자료구조
    - 컬렉션 프레임워크를 `자료구조` 라고 하며, 유지 및 개발에 사용할 자료를 어떤 구조로 관리할지 명시해놓은 것을 말한다.
    - Collection
      - List(순서가 있는 자료, 중복 허용)
        - ArrayList
          - Stack, Queue
          - 객체 순서를 기반으로 순차적 자료 관리를 구현할 때 사용
          - `Vector`와 같이 동기화가 필요하다면 `[synchronizedList](https://paciencia.tistory.com/31)`를 사용하여 선언하면 됨
        - Vector
          - `ArrayList` 와의 차이점 → 두 개 이상의 스레드가 동시에 Vector를 사용할 때에도 실행 순서를 보장함
          - `동기화` → JAVA의 작업 단위를 `스레드`라 하며, 두 개 이상의 스레드(`멀티스레드`)를 사용 할 때 오류 예방을 위해 두 스레드가 한 메모리에 동시 접근하지 못하도록 순서를 맞추는 것
          - 동기화 작업 때문에 속도는 `ArrayList`보다 느리다.
        - LinkedList
          - 물리적 메모리는 떨어져있으나, 각 요소가 다음 요소의 `주소값`을 가지고있다.
          - A→[data, BAdress], B→[data, CAdress] 의 형태이다.
          - 직접적인 자료 연결을 하지 않아도 되기 때문에 요소의 추가, 삭제가 `ArrayList`보다 빠르다.
          - 하지만, i번째 요소를 탐색하는 경우, 인덱스가 정해진 `ArrayList`가 훨씬 빠르며, 자료 변동이 많은 경우에만 활용하는 것이 좋다.
      - Set(순서가 없는 자료, 중복 허용하지 않음)
        - 순서가 없기 때문에 `Iterator`생성자를 활용하여 모든 요소의 순회가 가능하다.
        - HashSet
          - 자료가 입력된 순서대로 출력되지 않으며, 중복을 허용하지 않는다.
        - TreeSet
          - 중복을 허용하지 않으며, 출력 시 값을 정렬한다.
            - 정렬 시 `이진 트리`를 사용한다.
            - 요소를 추가할 때 정렬 기준을 구현하는 `Comparable`, `Comparator` 인터페이스가 구현되어야 한다.
            - `Comparable` → `compareTo` 메서드를 재정의해 사용하며 인자로 받은 객체와 this 를 비교하여 정렬한다.
            - `Comparator` → `compare` 메서드를 재정의해 사용하며, 두 인자를 받아 비교하며 정렬한다.
              - `TreeSet`생성자에 Comparator를 구현할 객체를 매개변수로 전달
    - Map
      - 키와 값으로 분류되는 자료를 관리(키는 중복될 수 없으며, 값은 중복될 수 있다.)
      - Hashtable
        - `Vector`클래스와 마찬가지로, 동기화를 제공하며, 해당 기능을 사용하지 않는다면 `HashMap`을 사용하는 것이 좋다.
      - HashMap
        - 해시 방식으로 자료를 관리하며, 해시 함수를 만들어 자료의 검색 속도를 빠르게 할 수 있다.
      - TreeMap
        - `TreeSet`과 마찬가지로 `이진 트리`를 사용하며, `Comparable`혹은 `Comparator`인터페이스를 구현해야한다.

## 2023.02.01

### 학습할 내용

- 내부 클래스
  - 정적 내부 클래스
  - 지역 내부 클래스
  - 인스턴스 내부 클래스
  - 익명 내부 클래스
- 람다식
  - 함수형 인터페이스
  - 익명 객체

### 학습한 내용

- 내부 클래스
  - 내부 클래스는 외부 클래스가 먼저 생성되어야 사용할 수 있으며, 인스턴스 내부 클래스의 메서드는 외부 클래스의 메서드가 호출될 때 사용이 가능하다.
  - `private`으로 선언되었다면 클래스 외부에선 사용이 불가능하다.
- 정적 내부 클래스
  - 외부 클래스 생성과 무관하게 내부 클래스 사용이 가능해야하며, 정적 변수를 사용해야한다면 정적 내부 클래스에 `static`예약어로 필요한 외부 클래스를 선언하면 된다.
- 지역 내부 클래스
  - 메서드 내부에 `Runnable` 인터페이스로 선언되며, 반드시 클래스 내부에 `run`을 오버라이딩 해 사용해야한다.
- 익명 내부 클래스
  - 말 그대로 외부 클래스 내 메서드의 반환값을 `new Runnable` 로 선언하며, 클래스 끝에 `;`를 붙여 마무리한 익명 클래스를 말한다.
- 람다식
  - 자바의 함수형 프로그래밍 방식을 `람다식`이라고 한다.
  ```java
  int add(int x, int y) {
  	return x + y
  }

  (int x, int y) -> {return x + y;} // 위 식과 같은 반환값을 갖는다.
  ```
  - 자바에선 참조 변수 없이 메서드를 호출할 수 없기 때문에 `람다식`은 함수형 인터페이스를 만들고 해당 인터페이스를 적용한 클래스 내에서 사용되어야 한다.
  - `@FunctionalInterface`애노테이션을 활용하면, 함수형 인터페이스 라는 의미를 나타내므로, 메서드를 두개 이상 추가할 시 오류가 발생한다.

## 2023.02.02

### 학습할 내용

- 스트림
  - reduce()
- 예외 클래스
  - 오류 & 예외
- 예외 처리
  - try-catch
  - try-catch-finally
  - try-with-resources
- 예외 미루기
  - throws
  - 다중 예외처리
- 사용자 정의 예외
- 자바 입출력
  - 스트림
- 표준 입출력
  - System.in
- 바이트 단위 스트림
  - InputStream
  - FileInputStream
  - OutputStream
  - FileOutputStream
- 문자 단위 스트림
  - Reader
  - FileReader
  - Writer
  - FileWriter
- 보조스트림
- 직렬화
  - 역직렬화
- 입출력 클래스
  - File클래스
  - RandomAccessFile 클래스

### 학습한 내용

- 스트림
  - `스트림`이란, 배열 요소를 특정 기준에 따라 정렬하거나, 일부 데이터를 필터 하는 기능 등을 미리 구현해놓은 클래스를 의미한다.
  - Arrays.stream(arrName), {arrayName}.stream() 의 구조로 생성되며, `JS`의 `filter`, `map`, `forEach`와 같은 문법을 사용한다.
  1. 한 번 생성하고 사용한 스트림은 소모되어 재사용이 불가
  2. 스트림의 연산으로 기존 자료가 변경되진 않음
- 예외 클래스
  - 오류
    - 코드 작성 중 발생하는 `컴파일 오류`
    - 실행 중 중지되는 `실행 오류`
  - 예외
    - 프로그램 내에서 해결이 가능한 문제
    - 최상위 클래스는 `Exception`
    - `try-catch`문을 사용하여 처리
    - 예외 처리는 프로그램이 비정상 종료되는 것을 방지하기 때문에 매우 중요하다.
    - 사용한 시스템 리소스는 반드시 닫아주어야 하며(`close`) `try-catch-finally`문을 이용하여 리소스를 종료시키면 된다.
    - `try-with-resources`문을 사용하면 내부에서 사용된 리소스는 자동으로 `close`된다.
      `AutoCloseable`을 인터페이스로 생성한 후 `close`메서드를 Override해 만든 후 `try-catch`문에서 선언하면, AutoClose가 된다.
    - `try-catch`문은 선언된 순서대로 검사하기 때문에 `Exception`처럼 최상위 예외처리를 먼저 선언한다면, 오류가 발생할 수 있다.
    - 사용자 정의 예외
      - `extends` 예약어로 `Exception`을 상속받아 `super`메서드로 사용자 정의 예외를 구현한다.
  - 스트림
    - 모든 입출력은 `스트림`을 통해 이루어짐
    - 입출력 장치와 무관히 일관성을 유지하기 위해 제공
      - 기반 스트림
        - 입력 스트림
        - 출력 스트림
        - Console
        - Scanner
        - FileInput
          - 파일을 출력하는 스트림 입니다.
        - FileOutput
          - 파일을 입력하는 스트림 입니다.
          - 입력된 숫자를 해당 아스키 코드로 생성함
        - Reader
          - 한글을 바이트 단위로 읽게되면 깨질 수 있기 때문에 `Reader`스트림을 활용해야한다.
        - Writer
      - 보조스트림
        - 예시, `InputStreamReader`는 보조스트림으로 기반 스트림인 `InputStream`을 매개변수로 받아 생성된다면, 바이트 단위로 읽은 내용을 문자로 변환해주기 때문에 한글도 읽을 수 있다.
        - Bufferd 스트림
          - 입출력이 한 바이트나 문자 단위로 이루어지면 성능 감소, 배열 및 문자열로 입출력을 이루어지게 하는 스트림
          - 실제 300MB 정도의 압축 파일을 바이트로 복사하는 테스트를 한 결과 300배 가량 `Buffered 스트림`이 빨랐음
      - 직렬화
        - 인스턴스의 특정 시점 상태를 저장하거나 네트워크로 전송하는 것
        - 인스턴스 내용을 연속 스트림으로 만들어 파일에 쓰거나 네트워크로 전송할 수 있게 함
        - 직렬화 하겠다는 선언으로 `Object implements Serializable`을 선언해야한다.
      - 역직렬화
        - 저장된 내용이나 전송받은 내용을 복원하는 것

## 2023.02.03

### 학습할 내용

- 복습 및 부족한 내용 보충

### 학습한 내용

- TIL
